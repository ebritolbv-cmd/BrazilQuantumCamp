# -*- coding: utf-8 -*-
"""5_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14GzlEemOeg7hyjIHiEMm7Dwk-UyaGiqc

# Brazil Quantum Camp

**Aula 5** Introdu√ß√£o √† Programa√ß√£o II
"""

import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from functools import reduce

"""## Fun√ß√µes e Portas Qu√¢nticas Apresentadas em Aula"""

def get_op_n_qubits(gate_matrix, target_qubit, total_qubits):
    """Constr√≥i a matriz de opera√ß√£o para N qubits"""
    # 1. Cria lista de Identidades: [I, I, I, ...]
    gates = [np.eye(2, dtype=complex)] * total_qubits

    # 2. Substitui a Identidade no
    # alvo pela porta desejada
    gates[target_qubit] = gate_matrix

    # 3. Faz o kron de tudo: I kron I kron U kron I ...
    # reduce aplica kron acumulativamente na lista
    full_op = reduce(np.kron, gates)

    return full_op


def get_cnot_matrix(n_qubits, control, target):
    """Constr√≥i a matriz CNOT para N qubits item a item."""
    size = 2**n_qubits
    control = n_qubits - 1 - control  # Ajusta √≠ndice
    target = n_qubits - 1 - target  # Ajusta √≠ndice
    U = np.zeros((size, size), dtype=complex)
    # Itera sobre todos os estados da base (colunas)
    for col in range(size):
        # Verifica se o bit de controle est√° ativo
        if (col >> control) & 1:
            # Se sim, o destino (linha) √© o √≠ndice com o bit alvo invertido
            row = col ^ (1 << target)
        else:
            # Se n√£o, o estado n√£o muda
            row = col
        # Define a transi√ß√£o |row><col|
        U[row, col] = 1.0
    return U


def plot(state: np.ndarray, **kwargs):
    """Plota o estado qu√¢ntico usando Plotly Express."""
    # 1. Preparando os dados
    # flatten(): Transforma matriz (4,1) em array plano (4,)
    raio = np.abs(state.flatten())
    angulo = np.angle(state.flatten())
    # 2. Gerando labels (|00>, |01>...) dinamicamente
    n_qubits = int(np.log2(len(state)))
    estados = [f"|{i:0{n_qubits}b}>" for i in range(len(raio))]
    # 3. Plotando
    # x=Estado, y=Amplitude, color=Fase
    fig = px.bar(x=estados, y=raio, color=angulo, **kwargs)
    return fig


def apply_mcz(state, qubits):
    """Aplica Z (fase -1) se TODOS os qubits listados forem 1."""
    n = int(np.log2(len(state)))
    # 1. Cria uma m√°scara com os qubits envolvidos
    mask = 0
    for q in qubits:
        mask |= 1 << (n - 1 - q)
    # 2. Itera sobre os estados da base
    for i in range(len(state)):
        # Verifica se todos os bits da m√°scara est√£o ligados em i
        if (i & mask) == mask:
            state[i] *= -1
    return state


def apply_mcx(state, controls, target):
    """Aplica a porta MCX (C...CX) a um estado qu√¢ntico."""
    # 1. Aplica H no alvo
    state = apply_gate(state, "H", target)

    # 2. Aplica MCZ
    state = apply_mcz(state, controls, target)

    # 3. Aplica H no alvo novamente
    state = apply_gate(state, "H", target)

    return state


def get_projectors(target, n_qubits):
    """Constr√≥i os operadores M0 e M1 expandidos para N qubits."""
    # Lista de Identidades
    ops0, ops1 = [np.eye(2, dtype=complex)] * n_qubits, [
        np.eye(2, dtype=complex)
    ] * n_qubits
    # Substitui a identidade no alvo pelo projetor
    ops0[target] = np.array([[1, 0], [0, 0]], dtype=complex)  # |0><0|
    ops1[target] = np.array([[0, 0], [0, 1]], dtype=complex)  # |1><1|
    # Cria as matrizes grandes (Tensor Product)
    M0, M1 = reduce(np.kron, ops0), reduce(np.kron, ops1)
    return M0, M1


def get_probability(state, M):
    """Calcula P(m) = || M|psi> ||^2"""
    # Projeta o estado (sem normalizar)
    projected_state = M @ state

    # A norma ao quadrado √© a probabilidade
    prob = np.linalg.norm(projected_state) ** 2

    # Retorna o estado projetado
    # para reuso e a probabilidade
    return prob, projected_state


def normalize(projected_state, prob):
    """Normaliza o estado: |psi'> = M|psi> / sqrt(P)"""

    return projected_state / np.sqrt(prob)


def measure(state, target_qubit):
    n = int(np.log2(len(state)))
    # 1. Obter Operadores
    M0, M1 = get_projectors(target_qubit, n)
    # 2. Calcular Probabilidades e Proje√ß√µes
    prob0, state0 = get_probability(state, M0)
    prob1, state1 = get_probability(state, M1)
    # 3. Sorteio (Natureza escolhe o resultado)
    # Nota: np.random.choice precisa de soma exata 1.0
    outcome = np.random.choice([0, 1], p=[prob0, 1 - prob0])
    # 4. Colapso Irrevers√≠vel
    final_state = normalize(state0, prob0) if outcome == 0 else normalize(state1, prob1)
    return outcome, final_state


def measure_all(state):
    """Mede todos os qubits de um estado qu√¢ntico."""
    n = int(np.log2(len(state)))
    results = []
    for qubit in range(n):
        bit, state = measure(state, qubit)  # Atualiza o estado a cada passo!
        results.append(bit)
    return results, state  # Estado final ser√° |b0 b1 ... bn>


def bloch_coordinates(ket):
    """Calcula as coordenadas de Bloch de um qubit."""
    bra = np.conj(ket.T)
    # Valor Esperado <O> = <psi|O|psi>
    x = (bra @ GATES["X"] @ ket).item().real
    y = (bra @ GATES["Y"] @ ket).item().real
    z = (bra @ GATES["Z"] @ ket).item().real
    return go.Scatter3d(
        x=[x],
        y=[y],
        z=[z],
        mode="markers",
        marker={"size": 10, "color": "red"},
    )


def bloch():
    """Gera a superf√≠cie da esfera."""
    phi = np.linspace(0, np.pi, 100)
    theta = np.linspace(0, 2 * np.pi, 200)
    phi, theta = np.meshgrid(phi, theta)

    # Convers√£o Esf√©rica -> Cartesiana
    x = np.sin(phi) * np.cos(theta)
    y = np.sin(phi) * np.sin(theta)
    z = np.cos(phi)

    return go.Surface(x=x, y=y, z=z, showscale=False, opacity=0.5)


def bloch_plot(ket):
    """Plota o estado de um qubit na esfera de Bloch."""
    # 1. Cria a Esfera
    sphere = bloch()
    # 2. Calcula o Ponto do Qubit
    point = bloch_coordinates(ket)
    # 3. Retorna a Figura Combinada
    return go.Figure(data=[sphere, point])


def create_state(n_qubits: int) -> np.ndarray:
    """Cria um estado qu√¢ntico inicializado no estado
    |0...0> para um dado n√∫mero de qubits."""
    ...


def apply_gate(state: np.ndarray, gate_name: str, target: int) -> np.ndarray:
    """Aplica uma porta qu√¢ntica de um qubit a um estado qu√¢ntico."""
    ...


def apply_cnot(state: np.ndarray, control: int, target: int) -> np.ndarray:
    """Aplica a porta CNOT a um estado qu√¢ntico."""
    ...


GATES = {
    "X": np.array([[0, 1], [1, 0]], dtype=complex),
    "Y": np.array([[0, -1j], [1j, 0]], dtype=complex),
    "Z": np.array([[1, 0], [0, -1]], dtype=complex),
    "H": (1 / np.sqrt(2)) * np.array([[1, 1], [1, -1]], dtype=complex),
    "RX": lambda theta: np.array(
        [
            [np.cos(theta / 2), -1j * np.sin(theta / 2)],
            [-1j * np.sin(theta / 2), np.cos(theta / 2)],
        ],
        dtype=complex,
    ),
    "RY": lambda theta: np.array(
        [
            [np.cos(theta / 2), -np.sin(theta / 2)],
            [np.sin(theta / 2), np.cos(theta / 2)],
        ],
        dtype=complex,
    ),
    "RZ": lambda theta: np.array(
        [
            [np.exp(-1j * theta / 2), 0],
            [0, np.exp(1j * theta / 2)],
        ],
        dtype=complex,
    ),
    "P": lambda theta: np.array(
        [
            [1, 0],
            [0, np.exp(1j * theta)],
        ],
        dtype=complex,
    ),
}

"""## **Exemplo**: Medida e Emaranhamento

**Estado Separ√°vel $\left|++\right>$**

$\frac{1}{2}(\left|00\right>+\left|01\right>+\left|10\right>+\left|11\right>)$

Medir o Qubit 0 **n√£o afeta** a probabilidade do Qubit 1.
Eles s√£o independentes.


"""

psi = np.array([1, 0, 0, 0], dtype=complex)
psi = np.kron(GATES["H"], GATES["H"]) @ psi

plot(psi, title="Estado ap√≥s aplicar H em ambos os qubits").show()

result0, psi = measure(psi, 0)

print("Resultado da medi√ß√£o do qubit 0:", result0)

plot(psi, title="Estado ap√≥s medi√ß√£o do qubit 0").show()

result1, psi = measure(psi, 1)

print("Resultado da medi√ß√£o do qubit 1:", result1)

plot(psi, title="Estado ap√≥s medi√ß√£o do qubit 1").show()

"""
**Estado de Bell**

$\frac{1}{\sqrt{2}}(\left|++\right>+\left|00\right>)$

1.  Medir Q0. Probabilidade 50/50.
2.  Suponha resultado $0$.
3.  O estado colapsa para $\left|01\right>$.
4.  A medida de Q1 agora ser√° $0$
    com **100%** de certeza.

O colapso de um qubit emaranhados afeta os demais."""

bell00 = np.array([1, 0, 0, 0], dtype=complex)
bell00 = np.kron(GATES["H"], np.eye(2)) @ bell00
bell00 = get_cnot_matrix(2, control=0, target=1) @ bell00

plot(bell00, title="Estado ap√≥s aplicar CNOT").show()

result0, bell00 = measure(bell00, 0)
print("Resultado da medi√ß√£o do qubit 0:", result0)

plot(bell00, title="Estado ap√≥s medi√ß√£o do qubit 0").show()

result1, bell00 = measure(bell00, 1)
print("Resultado da medi√ß√£o do qubit 1:", result1)

plot(bell00, title="Estado ap√≥s medi√ß√£o do qubit 1").show()

"""## Esfera de Bloch

"""

psi = np.array([1, 0], dtype=complex)
psi = GATES["RX"](np.pi / 4) @ psi
psi = GATES["RZ"](np.pi / 5) @ psi

bloch_plot(psi).show()

"""## üõ†Ô∏è **Desafio**: A Classe `QuantumCircuit`

Nossa meta √© preencher essa estrutura.
O estado qu√¢ntico (`self.state`) deve ser persistente entre as chamadas.
"""

class QuantumCircuit:
    def __init__(self, n_qubits: int):
        """Inicializa o circuito com |00...0>."""
        ...

    def x(self, target: int):
        """Aplica porta Pauli-X (NOT)."""
        ...

    def y(self, target: int):
        """Aplica porta Pauli-Y."""
        ...

    def z(self, target: int):
        """Aplica porta Pauli-Z."""
        ...

    def h(self, target: int):
        """Aplica porta Hadamard."""
        ...

    def rx(self, theta: float, target: int):
        """Aplica rota√ß√£o Rx por um √¢ngulo theta."""
        ...

    def ry(self, theta: float, target: int):
        """Aplica rota√ß√£o Ry por um √¢ngulo theta."""
        ...

    def rz(self, theta: float, target: int):
        """Aplica rota√ß√£o Rz por um √¢ngulo theta."""
        ...

    def p(self, phi: float, target: int):
        """Aplica porta de Fase (Phase Shift)."""
        ...

    def cnot(self, control: int, target: int):
        """Aplica CNOT (CX)."""
        ...

    def mcx(self, controls: list[int], target: int):
        """Aplica Toffoli Generalizado (Multi-Controlled X)."""
        self.state = apply_mcx(self.state, controls, target)

    def mcz(self, qubits: list[int]):
        """Aplica Z Controlado (fase -1 se todos forem 1)."""
        ...

    def measure(self, qubits: list[int]) -> list[int]:
        """Mede os qubit, colapsa o estado e retorna os bit."""
        ...

    def sphere(self) -> go.Figure:
        """
        Retorna uma figura Plotly com a Esfera de Bloch.
        Nota: V√°lido apenas para simula√ß√£o de 1 qubit.
        """
        ...

    def histogram(self) -> go.Figure:
        """
        Retorna um gr√°fico de barras com as probabilidades
        e fase de cada estado.
        """
        ...

"""## üß™ **Exerc√≠cio**: Codifica√ß√£o Superdensa

Usando a classe `QuantumCircuit`, implemente
o protocolo de Codifica√ß√£o Superdensa.

* Alice envia 2 bits cl√°ssicos transferindo 1 qubit.
* Usa portas $I, X, Z, ZX$ dependendo da mensagem.

![](https://upload.wikimedia.org/wikipedia/commons/b/b7/Superdense_coding.png)
"""

# Implementa√ß√£o da codifica√ß√£o superdensa

"""
## üß™ **Exerc√≠cio**: Teletransporte Qu√¢ntico

Usando a classe `QuantumCircuit`, implemente
o protocolo de Teletransporte Qu√¢ntico.


* Alice transfere o
  estado $\left|\psi\right>$ para Bob.
* Usando um par de Bell
  $$\left|\Phi\right>^+ = \frac{1}{\sqrt{2}}(\left|01\right>+\left|10\right>)$$



![](https://upload.wikimedia.org/wikipedia/commons/d/dc/Quantum_teleportation_circuit.svg)

Teste com $\left|\psi\right> = \frac{1}{\sqrt{2}}(\left|0\right>-\left|1\right>)$

"""

# Implementa√ß√£o do Teleporte Qu√¢ntico